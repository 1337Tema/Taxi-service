Основные потоки данных:
Сценарий 1: Заказ поездки

Пассажир → API Gateway → Order Service → Pricing Service → 
→ Driver Matching Service → Notification Service → Водитель
Сценарий 2: Обновление статуса водителя

Водитель → API Gateway → Driver Service → Location Service → 
→ Redis (геоданные) → Driver Matching Service
Сценарий 3: Назначение водителя

Driver Matching Service → Order Service → Notification Service → 
→ WebSocket → Водитель/Пассажир




2. Выбор БД и схема данных
PostgreSQL (основное хранилище)
Выбор обоснован: сложные запросы, реляционная целостность.

Таблицы:

-- Пользователи (водители и пассажиры)
CREATE TABLE users (
    id BIGSERIAL PRIMARY KEY,
    type VARCHAR(10) NOT NULL, -- 'driver' | 'passenger'
    email VARCHAR(255) UNIQUE NOT NULL,
    phone VARCHAR(20),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- Водители
CREATE TABLE drivers (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT REFERENCES users(id),
    status VARCHAR(20) DEFAULT 'offline', -- 'offline' | 'online' | 'busy'
    current_ride_id BIGINT, -- активная поездка
    rating DECIMAL(3,2),
    total_rides INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT NOW()
);

-- Пассажиры
CREATE TABLE passengers (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT REFERENCES users(id),
    rating DECIMAL(3,2),
    total_rides INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT NOW()
);

-- Поездки
CREATE TABLE rides (
    id BIGSERIAL PRIMARY KEY,
    passenger_id BIGINT REFERENCES passengers(id),
    driver_id BIGINT REFERENCES drivers(id),
    status VARCHAR(20) NOT NULL, -- 'pending' | 'driver_assigned' | 'driver_arrived' | 'passenger_onboard' | 'in_progress' | 'completed' | 'cancelled'
    
    -- Координаты
    start_x INTEGER NOT NULL,
    start_y INTEGER NOT NULL,
    end_x INTEGER NOT NULL,
    end_y INTEGER NOT NULL,
    
    -- Расчеты
    distance INTEGER NOT NULL, -- в клетках
    estimated_duration INTEGER NOT NULL, -- в секундах
    estimated_price DECIMAL(10,2) NOT NULL,
    final_price DECIMAL(10,2),
    
    -- Временные метки
    created_at TIMESTAMP DEFAULT NOW(),
    accepted_at TIMESTAMP,
    arrived_at TIMESTAMP,
    started_at TIMESTAMP,
    completed_at TIMESTAMP,
    cancelled_at TIMESTAMP,
    
    -- Индексы
    INDEX idx_status (status),
    INDEX idx_passenger_created (passenger_id, created_at),
    INDEX idx_driver_created (driver_id, created_at)
);

-- Тарифы
CREATE TABLE pricing_rules (
    id BIGSERIAL PRIMARY KEY,
    base_fare DECIMAL(10,2) NOT NULL,
    price_per_cell DECIMAL(10,2) NOT NULL,
    time_per_cell INTEGER NOT NULL, -- секунд на одну клетку
    min_fare DECIMAL(10,2) NOT NULL,
    surge_multiplier DECIMAL(3,2) DEFAULT 1.0,
    effective_from TIMESTAMP NOT NULL,
    effective_to TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW()
);
Redis (кеш и реальное время)
Выбор обоснован: низкая задержка, структуры данных для геопоиска, pub/sub.

Структуры:
redis
# Геопозиции онлайн-водителей (Sorted Set)
DRIVERS_LOCATIONS: {
    "driver_id1": "x,y",  # например "15,20"
    "driver_id2": "8,12"
}

# Очередь заказов (List)
PENDING_ORDERS: [order_id1, order_id2, ...]

# Сессии WebSocket
USER_SESSIONS: {
    "user_id1": "ws_session_id1",
    "user_id2": "ws_session_id2"
}

# Временные блокировки
DRIVER_LOCKS: {
    "driver_id1": "order_id123:timestamp"
}



3. Ключевые сервисы и их ответственность
3.1 API Gateway Service
Ответственность: Единая точка входа, аутентификация, маршрутизация
Технологии: Nginx + Lua / Spring Cloud Gateway
Функции:
JWT-аутентификация
Rate limiting
Маршрутизация запросов к микросервисам
WebSocket прокси

3.2 User Service
Ответственность: Управление пользователями, аутентификация
Функции:
Регистрация/авторизация
Профили пользователей
Валидация данных

3.3 Driver Service
Ответственность: Управление водителями
Функции:
Онлайн/офлайн статус
Блокировки водителей
Рейтинги и статистика

3.4 Location Service
Ответственность: Геоданные и позиции
Функции:
Обновление координат водителей
Поиск ближайших водителей
Валидация координат (в пределах сетки N×M)

3.5 Order Service
Ответственность: Управление заказами
Функции:
Создание заказов
Обновление статусов поездок
История поездок
Валидация бизнес-правил (одна активная поездка)

3.6 Pricing Service
Ответственность: Расчет стоимости и ETA
Функции:
Расчет расстояния (манхэттенское)
Расчет сколько ехать: distance * time_per_cell
Расчет цены: base_fare + (distance * price_per_cell) * surge_multiplier
Динамическое ценообразование

3.7 Driver Matching Service
Ответственность: Назначение водителей
Функции:
Поиск ближайшего доступного водителя
Алгоритм назначения (расстояние + приоритеты)
Очередь заказов
Таймауты подтверждения

3.8 Notification Service
Ответственность: Уведомления в реальном времени
Функции:
WebSocket соединения
Push-уведомления
Обновления статусов
Время езды обновления

3.9 Analytics Service
Ответственность: Метрики и аналитика
Функции:
Сбор метрик (время подачи, отказы, отмены)
Дашборды
Бизнес-аналитика

4. Ключевые API-эндпоинты

4.1 Аутентификация

POST /api/v1/auth/login
Content-Type: application/json
{
  "email": "user@example.com",
  "password": "password"
}
Response:
{
  "token": "jwt_token",
  "user_id": 123,
  "user_type": "driver|passenger"
}


4.2 Управление водителями

PUT /api/v1/drivers/{id}/status
Content-Type: application/json
Authorization: Bearer {token}
{
  "status": "online|offline",
  "current_x": 15,
  "current_y": 20
}
PUT /api/v1/drivers/{id}/location
Content-Type: application/json
Authorization: Bearer {token}
{
  "x": 15,
  "y": 20
}


4.3 Заказы

POST /api/v1/rides
Content-Type: application/json
Authorization: Bearer {token}
{
  "passenger_id": 123,
  "start_x": 10,
  "start_y": 15,
  "end_x": 25,
  "end_y": 30
}
Response:
{
  "ride_id": 456,
  "estimated_price": 15.50,
  "estimated_eta": 480, // секунды
  "distance": 30, // клетки
  "status": "pending"
}
PUT /api/v1/rides/{id}/status
Content-Type: application/json
Authorization: Bearer {token}
{
  "status": "cancelled|completed|etc"
}


4.4 История поездок

GET /api/v1/users/{id}/rides?page=1&limit=20
Authorization: Bearer {token}
Response:
{
  "rides": [
    {
      "id": 456,
      "status": "completed",
      "start_x": 10,
      "start_y": 15,
      "end_x": 25,
      "end_y": 30,
      "distance": 30,
      "final_price": 15.50,
      "created_at": "2024-01-15T10:30:00Z",
      "completed_at": "2024-01-15T10:45:00Z"
    }
  ],
  "total": 45,
  "page": 1
}

4.5 WebSocket эндпоинты
javascript
// Подписка на обновления
ws://api.taxi.com/ws?token={jwt_token}
// Сообщения:
{
  "type": "ride_status_update",
  "data": {
    "ride_id": 456,
    "status": "driver_assigned",
    "driver_info": {...},
    "eta": 300
  }
}
{
  "type": "location_update", 
  "data": {
    "driver_id": 789,
    "x": 12,
    "y": 18,
    "eta": 120
  }
}


4.6 Internal APIs (для сервисов)

POST /internal/v1/driver-matching/request
Content-Type: application/json
{
  "order_id": 456,
  "start_x": 10,
  "start_y": 15,
  "max_distance": 50
}
PUT /internal/v1/location/drivers/{id}
Content-Type: application/json
{
  "x": 15,
  "y": 20,
  "updated_at": "2024-01-15T10:30:00Z"
}


Дополнительные компоненты
Конфигурация

grid:
  size_x: 100
  size_y: 100
pricing:
  base_fare: 2.00
  price_per_cell: 0.50
  time_per_cell: 16  # секунд
  min_fare: 5.00
matching:
  driver_timeout: 30  # секунд на подтверждение
  search_radius: 50   # клеток



 "Отделы" нашего такси-сервиса
1. Приемная (API Gateway)
Что делает: Первый, кто встречает всех клиентов и водителей
Проверяет документы (логин/пароль)
Решает, в какой отдел направить запрос
Защищает от слишком частых запросов
Пример: Когда вы открываете приложение такси, сначала вы попадаете в "приемную"

2. Отдел кадров (User Service)
Что делает: Учет всех сотрудников и клиентов
Регистрирует новых водителей и пассажиров
Хранит паспортные данные (профили)
Следит, кто есть кто

3. Отдел водителей (Driver Service)
Что делает: Управляет всеми водителями
Отмечает, кто вышел на работу (online)
Кто ушел с работы (offline)
Кто сейчас занят поездкой

4. Картографический отдел (Location Service)
Что делает: Следит за всеми координатами
Запоминает, где находится каждый водитель
Город у нас - как шахматная доска 100×100 клеток
Координаты: от (0,0) до (99,99)
Как считаем расстояние:
text
Если водитель в точке (5,10), а пассажир в (8,15)
Расстояние = |8-5| + |15-10| = 3 + 5 = 8 клеток

5. Отдел заказов (Order Service)
Что делает: Обрабатывает все поездки
Создает новый заказ
Следит за статусом поездки
Хранит историю всех поездок
Статусы поездки:
text
1. Ожидание → 2. Водитель назначен → 3. Водитель прибыл → 
4. Пассажир в машине → 5. В пути → 6. Завершено
6. Бухгалтерия (Pricing Service)
Что делает: Считает стоимость и время
text
Стоимость = минимальная цена + (расстояние × цена за клетку)
Время = расстояние × время на клетку
Пример:
Минимальная цена = 50 руб.
Цена за клетку = 10 руб.
Время на клетку = 16 секунд
Поездка на 8 клеток:
Стоимость = 50 + (8 × 10) = 130 руб.
Время = 8 × 16 = 128 секунд

7. Диспетчерская (Driver Matching Service)
Что делает: Находит ближайшего водителя
Как работает:
Получает заказ с координатами пассажира
Ищет всех свободных водителей поблизости
Выбирает самого близкого
Если водитель не ответил за 30 секунд - ищет следующего

8. Отдел уведомлений (Notification Service)
Что делает: Сообщает всем о событиях
Отправляет уведомление водителю: "Новый заказ!"
Сообщает пассажиру: "Водитель назначен, ехать 5 минут"
Работает как громкая связь в диспетчерской


Как храним информацию

Основной архив (PostgreSQL)
Похоже на: Большая бухгалтерская книга, где все аккуратно записано в таблицы
Таблицы:
Водители - кто работает, их рейтинги, сколько поездок
Пассажиры - кто заказывает, их история
Поездки - каждая поездка со всеми деталями
Тарифы - правила расчета цен

Оперативная память (Redis)
Похоже на: Доска объявлений, где пишем то, что быстро меняется
Что храним:
Где сейчас находятся водители (координаты)
Кто из водителей свободен прямо сейчас
Очередь заказов, ждущих водителей
Временные блокировки (чтобы два заказа не дали одному водителю)

Как работает процесс заказа такси

Шаг 1: Пассажир заказывает такси
Пассажир: "Нужно такси от (10,15) до (25,30)"
Приемная → Бухгалтерия → Диспетчерская
Бухгалтерия считает:
Расстояние: |25-10| + |30-15| = 15 + 15 = 30 клеток
Время: 30 × 16 сек = 480 сек = 8 минут
Цена: 50 руб + (30 × 10 руб) = 350 руб

Шаг 2: Поиск водителя
Диспетчерская смотрит на доску объявлений:
Водитель А: координаты (12,18) - расстояние 5 клеток
Водитель Б: координаты (8,12) - расстояние 5 клеток
Водитель В: координаты (20,25) - расстояние 10 клеток
Выбирает ближайшего: Водитель А (работает дольше)

Шаг 3: Уведомление водителя
Отдел уведомлений: "Водитель А! У вас заказ в 5 клетках, ехать 8 минут"

Шаг 4: Водитель принимает заказ
Водитель А: "Принимаю заказ"
Диспетчерская → Отдел заказов → Отдел уведомлений
Отдел уведомлений пассажиру: "Водитель назначен, приедет через 5 минут"

Шаг 5: Отслеживание поездки
Картографический отдел каждые 10 секунд обновляет:
Где сейчас водитель
Сколько осталось до пассажира
Пассажир видит движение машины на карте


Что видят пользователи

Пассажир в приложении:

[ Карта города 100×100 ]
○ Ваше местоположение: (10,15)
○ Машина такси: (12,18) 
○ Ехать до вас: 5 минут
○ Стоимость: 350 руб

Водитель в приложении:

[ Карта города 100×100 ]
○ Ваше местоположение: (12,18)
○ Заказ: забрать в (10,15), отвезти в (25,30)
○ Ехать до пассажира: 5 минут
○ Заработок: 350 руб

Важные настройки системы

город:
  размер_по_x: 100 клеток
  размер_по_y: 100 клеток

тарифы:
  минимальная_цена: 50 руб
  цена_за_клетку: 10 руб
  время_на_клетку: 15 секунд

поиск_водителя:
  время_ожидания_ответа: 30 секунд
  максимальное_расстояние_поиска: 50 клеток
  
Что происходит при проблемах

Если водитель не отвечает:
Ждем 30 секунд
Ищем следующего ближайшего водителя
Если водителей нет - ставим заказ в очередь

Если приложение упало:
Все данные сохранены в основном архиве
После перезапуска система продолжает работать
Водители и пассажиры видят актуальное состояние

Как следим за качеством работы
Считаем метрики:
Сколько заказов в час
Сколько времени ждут пассажиры
Сколько водителей отказываются от заказов
Среднее время поездки
Процент отмененных поездок

